# Java 进制转换和位运算

## Java 进制转换

**二进制**的基数为 2，表示二进制的位数只有 0 和 1、超过 1 时就必须进位，在 Java 中，二进制数以 0b 或 0B 开头。

**八进制**的基数为 8，表示八进制的位数只能是 0 到 7 之间，超过 7 时，必须进位，在 Java 中，八进制数以 0 开头（不推荐使用，易混淆）。

**十进制**的基数为 10，表示十进制的位数只能是 0 到 9 之间，超过 9 时，必须进位。在 Java 中，默认使用的数值就是十进制。

**十六进制**的基数为 16，表示十六位进制的位数只能是 0 到 14 之间，超过 15 时，必须进位，在十六进制中超过 9 之后使用字母表示数字，因为位数只能由一个符号表示，故十六进制中的 10 到 14 表示为 A 到 F，在 Java 中，十六进制数以 0x 或者 0X 开头。


### Java 内置的进制转换方法

```java
// 将10进制转成二进制字符串，输出 101
String binaryString = Integer.toBinaryString(5);
// 将10进制转成八进制字符串，输出 24
String octalString = Integer.toOctalString(20);
// 将10进制转成十六进制字符串，输出 14
String hexString = Integer.toHexString(20);

// 将二进制字符串转成十进制，输出 5
Integer num = Integer.valueOf("101", 2);

```

## 二进制位运算

### 位与（&）运算

位数进行与（&）运算时，只有全部为 1 的，结果才是 1。

```java
// 注意 int 类型是 32 位的，故 0b101 是等于 0b00000000000000000000000000000101 的简写, 故以下结果输出 101 
System.out.println(Integer.toBinaryString(0b10101 & 0b101));
// 输出 1
System.out.println(Integer.toBinaryString(0b1 & 0b1));
// 输出 0
System.out.println(Integer.toBinaryString(0b1 & 0b0));
```

二进制的位与运算常用于以下场景：

1. 位掩码，用于提取或检查特定位的状态

```java
// 检查一个数的第 3 位是否为 1 , 如果输出的结果大于 0 则说明位数为 1 
System.out.println(30 & 0b1000); 
```

2. 清零特定位，通过与 0 进行 AND 运算，可以屏蔽（清零）特定位
   
```java
// 低 4 位变 0，高 8 位不变，输出：
System.out.println(Integer.toBinaryString( 11200 & 0xFF0));

// 保留低 4 为，高位全部清零，表示截取低 4 位的值
System.out.println(Integer.toBinaryString( 57 & 0xF));
```

3. 奇偶性判断
   
```java
// 检查最低位是否为1，用于快速判断奇偶。
if( num & 1 == 1 && num != 0 ) {
    // 偶数，注意偶数是能被2整数除的数，0 是一个特殊的数字，既不是偶数也不是奇数 
}else {
    // 奇数
}
```

### 位或（|）运算

位数进行位或（|）运算时，只要位数有一个是 1 ，那么结果就是 1，否则结果就是 0。

位或运算主要用于以下场景

1. 置位特定位

```java
// 将某数的第2位（从0开始计）设为 1，无论 num 原来的第 2 位是 0 还是 1，执行后都变为 1  
num = num | 0b0100; // 或 num |= (1 << 2);
```

### 位异或（^）运算

位数进行位异或（^）运算时，只有两位都是 1 或 0 时，结果才为 1，否则结果为 0。

例如：` 1 ^ 1 = 1 `、` 0 ^ 0 = 1 `、` 0 ^ 1 = 0 `、` 1 ^ 0 = 0 `。

位异或运算常用于以下场景

1. 数据交换（不需要中间临时变量）
```java
int a = 10;
int b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;
// 输出 a = 20, b = 10 
System.out.println(a);
System.out.println(b);
```

### 取反与（~）运算

对位数进行取反运算，即为将 1 变为 0，将 0 变为 1，例子如下：

```java
// int 类型有 32 位，以下结果输出: 32
System.out.println(Integer.toBinaryString( ~0b1010).length());
// 输出结果: 11111111111111111111111111110101
System.out.println(Integer.toBinaryString( ~0b1010));
```


### 位左移运算（<<）

左移运算（<<）表示将二进制数向左移动 n 位，右侧补 0，相当于乘以2ⁿ。

主要有以下用途

1. 快速乘法（乘以 2 的幂）

```java
int x = 5;
int y = x << 2;    // 等价于 x * 4 = 20
int z = x << 3;    // 等价于 x * 8 = 40
// 注意：对于有符号数，溢出时行为未定义（C/C++）
```

2. 创建位掩码

```java
// 创建连续位的掩码，如低5位为1：0b11111
int mask = (1 << 5) - 1;  // 1<<5=0b100000，减 1=0b011111
```

3. 数据组合与打包，将多个小数据组合成一个大数据

```java
// 将4个8位字节打包成32位整数
uint8_t a=0x12, b=0x34, c=0x56, d=0x78;
uint32_t combined = (a << 24) | (b << 16) | (c << 8) | d;
// 结果：0x12345678
```

### 右移运算（>>）

右移运算将二进制数向右移动n位，左侧补0或补符号位，相当于除以2ⁿ并取整。

右移运算主要有以下用途：

1. 快速除法（除以2的幂）
   
```java
unsigned int x = 20;
unsigned int y = x >> 2;   // 等价于 x / 4 = 5（向下取整）

int a = -20;
int b = a >> 2;           // 通常得-5（算术右移，保持负数）

// 计算两个数的中点（防溢出写法）
int mid = (low + high) >> 1;  // 等价于 (low + high) / 2， 在二分查找中常用
```

2. 提取特定位或字段，如从打包的数据中提取特定部分

```java
// 从32位RGB值中提取红色分量（假设格式为0xRRGGBB）
uint32_t color = 0xFF3366;
uint8_t red = (color >> 16) & 0xFF;   // 0xFF
uint8_t green = (color >> 8) & 0xFF;  // 0x33
uint8_t blue = color & 0xFF;          // 0x66

// 提取IP地址的各个部分
uint32_t ip = 0xC0A8010A; // 192.168.1.10
uint8_t octet1 = (ip >> 24) & 0xFF; // 192
uint8_t octet2 = (ip >> 16) & 0xFF; // 168
```