<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vianlex&#39;s Wiki</title>
  
  <subtitle>个人知识记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-31T13:39:26.114Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Vianlex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/wiki/index/"/>
    <id>http://example.com/wiki/index/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitHub-Pages-GitHub-Action-Hexo-搭建自动部署的静态网站"><a href="#GitHub-Pages-GitHub-Action-Hexo-搭建自动部署的静态网站" class="headerlink" title="GitHub Pages + GitHub Action + Hexo 搭建自动部署的静态网站"></a>GitHub Pages + GitHub Action + Hexo 搭建自动部署的静态网站</h1><h2 id="GitHub-Pages-搭建静态网站"><a href="#GitHub-Pages-搭建静态网站" class="headerlink" title="GitHub Pages 搭建静态网站"></a>GitHub Pages 搭建静态网站</h2><p>1、静态网站的 github 仓库名称必须满足格式：用户名称.github.io，静态网站的访问地址即是仓库的名称，如下图，创建的仓库静态网页 github 仓库名为 vialex.github.io, 则要访问该仓库的静态网页，配置后浏览器访问 vianlex.github.io 即可。<br><img src="/images/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E%E5%9B%BE.png" alt="静态网站仓库名称设置说明图"></p><p>2、创建一个 ph-pages 分支， 并在仓库的 settings 中指定静态网站使用 ph-pages 分支，main 分支存放搭建 hexo 网站的源码，ph-pages 存放 hexo 编译后的静态网页源码，设置好后，浏览器访问 vianlex.github.io 会默认访问 pg-pages 分支下的 index.html 文件，静态网站使用分支设置如下图：<br><img src="/images/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%88%86%E6%94%AF%E8%AE%BE%E7%BD%AE%E5%9B%BE.png" alt="静态网站分支设置图"></p><p>3、vianlex.github.io 静态网站使用仓库的 main 分支存放 hexo 源码，pg-pages 分支存放 hexo 编译后静态文件，另一种方式也可以使用一个仓库存放 hexo 源码，一个仓库存放 hexo 编译后的静态文件。</p><h2 id="手动使用-hexo-deploy-部署静态网站"><a href="#手动使用-hexo-deploy-部署静态网站" class="headerlink" title="手动使用 hexo deploy 部署静态网站"></a>手动使用 hexo deploy 部署静态网站</h2><p>使用 hexo deploy 部署静态网站，其实就是把我们搭建 hexo 网站编译，并将编译后的静态网站源码推送到 pg-pages 分支,  使用 hexo deploy 部署必须安装 hexo-deployer-git 插件和修改 _config.yml 中 deploy 参数。</p><p>1、安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2、修改  _config.yml 配置文件<br>以下配置的作用：是使用 hexo deploy 编译 hexo 源码后，将生成的静态网页，推送到指定的仓库和分支，推送的仓库类型可以是 git、gitlab 或者其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git  </span><br><span class="line">  repo: git@github.com:vianlex/vianlex.github.io.git  # 指定我们静态网站部署 github 仓库</span><br><span class="line">  branch: gh-pages  # 因为上面我们上面设置 vianlex.github.io 静态网站指定的分支是 ph-pages，所以要将编译后的静态网站源码推动到该分支</span><br></pre></td></tr></table></figure><h2 id="GitHub-Actions-自动部署静态网站"><a href="#GitHub-Actions-自动部署静态网站" class="headerlink" title="GitHub Actions 自动部署静态网站"></a>GitHub Actions 自动部署静态网站</h2><p>自动部署静态网站也需要跟手动部署一样，安装好 hexo-deployer-git 插件和配置好 _config.yml 中 deploy 参数，自动部署其实就是利用 Github 提供的 Github Action 代替我们的手动执行 hexo deploy，<br>要想使用 Github Actions 流水线要做的几个部署如下。</p><p>1、生成部署密钥命令如下：</p><p>密钥可以使用自己以前生成过的访问 github 或者访问其他应用的 ssh 密钥，不过为安全最好是单独生成新的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ssh-keygen -t rsa  -f github-deploy-key</span><br><span class="line"></span><br><span class="line">-t 指定密钥的类型，可以省略</span><br><span class="line">-f 指定密钥文件名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、 在仓库的 settings 配置刚才生成的密钥，公钥和私钥的配置是为 GitHub Actions 流水线编译部署能将 hexo 源码编译的静态网站源码推送到仓库的 ph-pages 分支<br>2.1、设置访问仓库的公钥，如下图：<br><img src="/images/%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93%E7%9A%84%E5%85%AC%E9%92%A5.png" alt="设置访问仓库的公钥"><br>2.2、设置访问仓库需要的私钥，如下图：<br><img src="/images/%E8%AE%BE%E7%BD%AE%E4%BB%93%E5%BA%93%E8%AE%BF%E9%97%AE%E7%A7%81%E9%92%A5.png" alt="设置仓库访问私钥"></p><p>3、在仓库根目录下创建 .github&#x2F;workflows 目录，并目录创建一个 yml 类型的文件，文件名称随意取，然后文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 指定 GitHub Actions 流水线的名称，即在仓库的 GitHub Actions 流水线列表中的显示的名字</span><br><span class="line">name: auto-deploy-hexo-ci</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  # 设置 Github Actions 流水线的触发方式，使用 git push 的时候触发</span><br><span class="line">  push:  </span><br><span class="line">    branches:</span><br><span class="line">      # 指定触发的分支，main 分支 git push 的时候触发流水线</span><br><span class="line">      - main  </span><br><span class="line"></span><br><span class="line"># 指定环境变量，方便引用，用到的时候使用 $&#123;&#123; env.GIT_USER&#125;&#125; 引用即可</span><br><span class="line">env:</span><br><span class="line">  GIT_USER: vianlex</span><br><span class="line">  GIT_EMAIL: zhouykwork@outlook.com</span><br><span class="line">  DEPLOY_REPO: vianlex/vianlex.github.io</span><br><span class="line">  DEPLOY_BRANCH: main</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    strategy:</span><br><span class="line">      # 指定 node 和 os 版本 矩阵指定多版本</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node_version: [12.x]</span><br><span class="line">    # $&#123;&#123;matrix.node_version&#125;&#125; 即使是引用上面定义的版本</span><br><span class="line">    name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125;</span><br><span class="line">    runs-on: $&#123;&#123; matrix.os &#125;&#125;</span><br><span class="line">    # 流水线执行的步骤</span><br><span class="line">    steps:</span><br><span class="line">      # 第一步，指定拉取hexo 源码仓库分支，repository 和 ref 使用变量引用上面配置的仓库和分支</span><br><span class="line">      - name: Checkout deploy repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125;</span><br><span class="line">      # 第二步，指定使用的 node 版本</span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class="line">      # 第三步，设置运行环境的系统变量，并配置访问仓库的密钥，因为流水线编译 hexo 要将编译后的源码推送到仓库的 ph-pages 分支</span><br><span class="line">      - name: Configuration environment</span><br><span class="line">        env:</span><br><span class="line">          # $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125; 表示引用的是仓库配置 settings-&gt;secrets 中的标题名称是 HEXO_DEPLOY_PRI 的私钥</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          # 在流水线的主机的用户目录下创建 .ssh 目录，并将我们在仓库设置的私钥复制到其中</span><br><span class="line">          mkdir -p ~/.ssh/</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">          chmod 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan github.com &gt; ~/.ssh/known_hosts</span><br><span class="line">          # 配置访问仓库的用户名和邮箱</span><br><span class="line">          git config --global user.name $GIT_USER</span><br><span class="line">          git config --global user.email $GIT_EMAIL</span><br><span class="line">      # 第四步，安装 hexo 依赖</span><br><span class="line">      - name: Install dependencies</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install</span><br><span class="line">      # 第五步，运行 hexo 部署命令</span><br><span class="line">      - name: Hexo deploy</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、配置好后，每次 main 分支 git push 的时候 GitHub Actions 都会触发上面配置的流水线，流水线执行状态，如下图可查看：<br><img src="/images/GitHub-Actions%E5%88%97%E8%A1%A8.png" alt="GitHub Actions 列表"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="https://lujiahao0708.github.io/p/df27ccfb.html">https://lujiahao0708.github.io/p/df27ccfb.html</a><br>2、<a href="https://dslwind.github.io/2021-04-20-github-action-hexo">https://dslwind.github.io/2021-04-20-github-action-hexo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GitHub-Pages-GitHub-Action-Hexo-搭建自动部署的静态网站&quot;&gt;&lt;a href=&quot;#GitHub-Pages-GitHub-Action-Hexo-搭建自动部署的静态网站&quot; class=&quot;headerlink&quot; title=&quot;GitHub</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Node 环境配置说明</title>
    <link href="http://example.com/wiki/NodeJs/Node%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/wiki/NodeJs/Node%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-config-命令说明"><a href="#npm-config-命令说明" class="headerlink" title="npm config 命令说明"></a>npm config 命令说明</h2><p>使用 npm help config 可以查看 npm 配置帮助文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 查看全局或者用户级别的配置文件路径</span></span><br><span class="line">npm config get [ globalconfig | userconfig]</span><br><span class="line"><span class="comment">// 编辑配置全局或者用户级别的配置文件</span></span><br><span class="line">npm config edit [userconfig | globalconfig]</span><br><span class="line"><span class="comment">// 显示当前环境的配置属性</span></span><br><span class="line">npm config list 或者 npm config ls</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="npm-install-g-cli-package"><a href="#npm-install-g-cli-package" class="headerlink" title="npm install -g [cli package]"></a>npm install -g [cli package]</h2><p>安装全局 CLI 命令包，是需要将 node_global 添加到环境变量中, 才能直接在终端中使用</p><h2 id="npm-配置文件说明"><a href="#npm-配置文件说明" class="headerlink" title="npm 配置文件说明"></a>npm 配置文件说明</h2><p>使用 npm set(修改用户级别配置的命令) 和 npm golabl set(修改全局配置的命令) 命令修改配置文件，都会直接写入对应的级别的配置文件中，所以也可以直接修改配置文件也是一样的效果，npm 配置的查找顺序如下：</p><p>项目的配置文件(&#x2F;path&#x2F;to&#x2F;user&#x2F;project&#x2F;.npmrc)<br>用户的配置文件($HOME&#x2F;.npmrc)<br>全局配置文件($PREFIX&#x2F;etc&#x2F;npmrc)<br>npm 内置配置文件(&#x2F;path&#x2F;to&#x2F;npm&#x2F;npmrc)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;npm-config-命令说明&quot;&gt;&lt;a href=&quot;#npm-config-命令说明&quot; class=&quot;headerlink&quot; title=&quot;npm config 命令说明&quot;&gt;&lt;/a&gt;npm config 命令说明&lt;/h2&gt;&lt;p&gt;使用 npm help config</summary>
      
    
    
    
    <category term="NodeJs" scheme="http://example.com/categories/NodeJs/"/>
    
    
  </entry>
  
  <entry>
    <title>使用出现问题记录</title>
    <link href="http://example.com/wiki/PowerDesigner/%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/wiki/PowerDesigner/%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提示-the-object-has-no-symbol"><a href="#提示-the-object-has-no-symbol" class="headerlink" title="提示 the object has no symbol"></a>提示 the object has no symbol</h2><p>在 Workspace 中找到应对 PDM 或者 CDM 的 PhysicalDiagram 然后右键选择 show symbols 再选择要显示的对象即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;提示-the-object-has-no-symbol&quot;&gt;&lt;a href=&quot;#提示-the-object-has-no-symbol&quot; class=&quot;headerlink&quot; title=&quot;提示 the object has no symbol&quot;&gt;&lt;/a&gt;提示 th</summary>
      
    
    
    
    <category term="PowerDesigner" scheme="http://example.com/categories/PowerDesigner/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL 逆向导入生成 PDM</title>
    <link href="http://example.com/wiki/PowerDesigner/%E9%80%86%E5%90%91%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/wiki/PowerDesigner/%E9%80%86%E5%90%91%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆向导入-MySQL-表结构例子"><a href="#逆向导入-MySQL-表结构例子" class="headerlink" title="逆向导入 MySQL 表结构例子"></a>逆向导入 MySQL 表结构例子</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><img src="/images/SQL%E9%80%86%E5%90%91%E7%94%9F%E6%88%90PMD%E6%AD%A5%E9%AA%A4-1.png" alt="SQL逆向生成PMD步骤-01"></p><h4 id="第二步、DBMS-需要选择-MySql"><a href="#第二步、DBMS-需要选择-MySql" class="headerlink" title="第二步、DBMS 需要选择 MySql"></a>第二步、DBMS 需要选择 MySql</h4><p><img src="/images/SQL%E9%80%86%E5%90%91%E7%94%9F%E6%88%90PMD%E6%AD%A5%E9%AA%A4-2.png" alt="SQL逆向生成PMD步骤-02"></p><h3 id="第三步、选择要导入的建表-SQL-脚本"><a href="#第三步、选择要导入的建表-SQL-脚本" class="headerlink" title="第三步、选择要导入的建表 SQL 脚本"></a>第三步、选择要导入的建表 SQL 脚本</h3><p><img src="/images/SQL%E9%80%86%E5%90%91%E7%94%9F%E6%88%90PMD%E6%AD%A5%E9%AA%A4-3.png" alt="SQL逆向生成PMD步骤-03"></p><h2 id="查看-Colums-没有-comment-注释列的话，可以-CTRL-U-选择显示-comment-即可"><a href="#查看-Colums-没有-comment-注释列的话，可以-CTRL-U-选择显示-comment-即可" class="headerlink" title="查看 Colums 没有 comment 注释列的话，可以 CTRL+U 选择显示 comment 即可"></a>查看 Colums 没有 comment 注释列的话，可以 CTRL+U 选择显示 comment 即可</h2><p><img src="/images/SQL%E9%80%86%E5%90%91%E7%94%9F%E6%88%90PMD%E6%AD%A5%E9%AA%A4-4.png" alt="SQL逆向生成PMD步骤-04"></p><h2 id="SQL-逆向导入生成-PDM-没有导入-COMMENT-注释问题"><a href="#SQL-逆向导入生成-PDM-没有导入-COMMENT-注释问题" class="headerlink" title="SQL 逆向导入生成 PDM 没有导入 COMMENT 注释问题"></a>SQL 逆向导入生成 PDM 没有导入 COMMENT 注释问题</h2><p>解决的方式是，把建表语句中字段设置的默认值和字符集全去掉，只保留字段的类型和注释，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">`id` VARCHAR(50)  COMMENT &#x27;用户 ID&#x27;,</span><br><span class="line">`username` VARCHAR(50) COMMENT &#x27;用户名&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) COLLATE=&#x27;utf8mb4_0900_ai_ci&#x27; ENGINE=InnoDB COMMENT &#x27;用户表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="将生成的-PDM-转-CDM"><a href="#将生成的-PDM-转-CDM" class="headerlink" title="将生成的 PDM 转 CDM"></a>将生成的 PDM 转 CDM</h2><p>菜单栏上选择 Tools 然后选择 Generate conceptual Data Model 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;逆向导入-MySQL-表结构例子&quot;&gt;&lt;a href=&quot;#逆向导入-MySQL-表结构例子&quot; class=&quot;headerlink&quot; title=&quot;逆向导入 MySQL 表结构例子&quot;&gt;&lt;/a&gt;逆向导入 MySQL 表结构例子&lt;/h2&gt;&lt;h3 id=&quot;第一步&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="PowerDesigner" scheme="http://example.com/categories/PowerDesigner/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 缓存穿透、缓存击穿、缓存雪崩</title>
    <link href="http://example.com/wiki/Redis/Redis%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/"/>
    <id>http://example.com/wiki/Redis/Redis%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<p>使用缓存的目的时为提高响应的效率和并发量，以及减少数据库的压力，如果缓存出现穿透、击穿、雪崩，就是失去了使用缓存的目录和意义，没有了缓存流量直通数据库，数据库压力增大，可能会就会导致系统崩溃。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="穿透说明"><a href="#穿透说明" class="headerlink" title="穿透说明"></a>穿透说明</h3><p>缓存穿透是要查询的数据在缓存中查询不到，在数据库中也查询不到，因为数据库中没有，每次查询之后都无法写入缓存，就导致每次查询数据都是直接查询数据库，当高并发或人为恶意查询数据，就会造成数据库的压力剧增、或者崩溃。<br><img src="/images/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="缓存穿透"></p><h3 id="穿透出现场景"><a href="#穿透出现场景" class="headerlink" title="穿透出现场景"></a>穿透出现场景</h3><p>1、原有的数据在缓存中和数据库中已经删除，前端仍然有关联的数据查询，未去掉。<br>2、人为的利用不存在的 key 恶意尝试请求，攻击系统。</p><h3 id="穿透的处理方案"><a href="#穿透的处理方案" class="headerlink" title="穿透的处理方案"></a>穿透的处理方案</h3><p>1、查询到空值时也将缓存设置默认值或者空，有效期设置短一些如3分钟，同时数据库写入数据时，必须更新缓存。<br>2、校验数据的有效性，防止恶意的 key 请求。<br>3、黑名单限制，防止恶意请求。<br>4、使用布隆过滤器，数据库写入数据时，先使用布隆过滤器标记，查询缓存没有数据时，查询布隆过滤器判断是否存在数据，不存在直接返回，存在在查询数据库。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="雪崩说明"><a href="#雪崩说明" class="headerlink" title="雪崩说明"></a>雪崩说明</h3><p>在使用缓存时，通常会对缓存设置过期时间，一方面目的是保持缓存与数据库数据的一致性，另一方面是减少冷缓存占用过多的内存空间。一个时刻出现大规模的缓存失效的情况或者 Redis 服务崩溃的情况下，大量的请求全部转发到数据库，从而导致数据库压力骤增，甚至宕机。从而形成一系列的连锁反应，造成系统崩溃等情况，就是缓存雪崩。<br><img src="/images/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="缓存雪崩"></p><h3 id="雪崩出现场景"><a href="#雪崩出现场景" class="headerlink" title="雪崩出现场景"></a>雪崩出现场景</h3><p>1、大量热点 key 同时失效。<br>2、redis 集群彻底崩溃。</p><h3 id="雪崩的处理方案"><a href="#雪崩的处理方案" class="headerlink" title="雪崩的处理方案"></a>雪崩的处理方案</h3><p>1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。<br>2、使用熔断机制。当流量到达一定的阈值时，就直接返回系统拥挤之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。<br>3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。<br>4、为了防止 Redis 宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="击穿说明"><a href="#击穿说明" class="headerlink" title="击穿说明"></a>击穿说明</h3><p>缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是一个热点的 Key，有大并发集中对该 key 进行访问，因为没有缓存，一瞬间的大量并发请求直接打到数据库。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" alt="缓存击穿"></p><h3 id="击穿的处理方案"><a href="#击穿的处理方案" class="headerlink" title="击穿的处理方案"></a>击穿的处理方案</h3><p>1、如果业务允许的话，对于热点的key可以设置永不过期的key。<br>2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，同时也会来的一个问题使用锁导致性能变差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用缓存的目的时为提高响应的效率和并发量，以及减少数据库的压力，如果缓存出现穿透、击穿、雪崩，就是失去了使用缓存的目录和意义，没有了缓存流量直通数据库，数据库压力增大，可能会就会导致系统崩溃。&lt;/p&gt;
&lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Awk 基础用法</title>
    <link href="http://example.com/wiki/Shell/Awk%20%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/wiki/Shell/Awk%20%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    
    
    
    <category term="Shell" scheme="http://example.com/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>Sed 基础用法</title>
    <link href="http://example.com/wiki/Shell/Sed%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/wiki/Shell/Sed%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    
    
    
    <category term="Shell" scheme="http://example.com/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot 属性配置</title>
    <link href="http://example.com/wiki/SpringBoot/SpringBoot%20%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/wiki/SpringBoot/SpringBoot%20%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置读取"><a href="#配置读取" class="headerlink" title="配置读取"></a>配置读取</h2><p>SpringBoot 属性配置支持 properties 文件、YAML文件、环境变量和命令行参数。 Spring Boot 提供的 SpringApplication 类会搜索并加载配置文件来获取配置属性值。SpringBoot 启动运行 SpringApplication 类的 run 方法时，会以下位置搜索配置文件：</p><ul><li>当前目录的 ／config 子目录</li><li>当前目录</li><li>classpath 中的 &#x2F;config 包</li><li>classpath</li></ul><h2 id="配置的访问"><a href="#配置的访问" class="headerlink" title="配置的访问"></a>配置的访问</h2><ol><li><p>通过 @ConfigurationProperties 绑定到 Bean 对象</p></li><li><p>在 Bean 对象中通过 @Value 注解引用</p></li><li><p>通过 Spring 提供的 Environment 类访问</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置读取&quot;&gt;&lt;a href=&quot;#配置读取&quot; class=&quot;headerlink&quot; title=&quot;配置读取&quot;&gt;&lt;/a&gt;配置读取&lt;/h2&gt;&lt;p&gt;SpringBoot 属性配置支持 properties 文件、YAML文件、环境变量和命令行参数。 Spring Boot</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://example.com/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>Dom4j 入门笔记</title>
    <link href="http://example.com/wiki/Xml/Dom4j%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/Xml/Dom4j%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-引入依赖包"><a href="#Maven-引入依赖包" class="headerlink" title="Maven 引入依赖包"></a>Maven 引入依赖包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.dom4j/dom4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- xpath  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建-XML"><a href="#创建-XML" class="headerlink" title="创建 XML"></a>创建 XML</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.vianlex.xml.dom4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.OutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.XMLWriter;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4jTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建 xml </span></span><br><span class="line"><span class="comment"> * &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment"> * &lt;beans&gt; </span></span><br><span class="line"><span class="comment"> * &lt;bean id=&quot;userService&quot; class=&quot;com.github.vianlex.service.impl.UserServiceImpl&quot;&gt;</span></span><br><span class="line"><span class="comment"> * &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;bean id=&quot;roleService&quot; class=&quot;com.github.vianlex.service.impl.RoleServiceImpl&quot;&gt; </span></span><br><span class="line"><span class="comment"> *      &lt;property name=&quot;roleDao&quot; ref=&quot;roleDao&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;bean id=&quot;roleDao&quot; class=&quot;com.github.vianlex.dao.RoleDao&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;bean id=&quot;userDao&quot; class=&quot;com.github.vianlex.dao.UserDao&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> * &lt;beans&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createXml</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> DocumentHelper.createDocument();</span><br><span class="line"><span class="comment">// 创建 &lt;beans&gt; 标签</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.addElement(<span class="string">&quot;beans&quot;</span>);</span><br><span class="line"><span class="comment">// 创建 &lt;beans&gt; 的子标签 &lt;bean&gt;</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">userServiceBean</span> <span class="operator">=</span> root.addElement(<span class="string">&quot;bean&quot;</span>).addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;userService&quot;</span>).addAttribute(<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.github.vianlex.service.impl.UserServiceImpl&quot;</span>);</span><br><span class="line"><span class="comment">// 创建 &lt;bean&gt; 的子标签 &lt;property&gt;</span></span><br><span class="line">userServiceBean.addElement(<span class="string">&quot;property&quot;</span>).addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;userDao&quot;</span>).addAttribute(<span class="string">&quot;ref&quot;</span>, <span class="string">&quot;userDao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">roleServiceBean</span> <span class="operator">=</span> root.addElement(<span class="string">&quot;bean&quot;</span>).addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;roleService&quot;</span>).addAttribute(<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.github.vianlex.service.impl.RoleServiceImpl&quot;</span>);</span><br><span class="line">roleServiceBean.addElement(<span class="string">&quot;property&quot;</span>).addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;roleDao&quot;</span>).addAttribute(<span class="string">&quot;ref&quot;</span>, <span class="string">&quot;roleDao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">userDao</span> <span class="operator">=</span> root.addElement(<span class="string">&quot;bean&quot;</span>).addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;roleDao&quot;</span>).addAttribute(<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.github.vianlex.dao.RoleDao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">roleDao</span> <span class="operator">=</span> root.addElement(<span class="string">&quot;bean&quot;</span>).addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;userDao&quot;</span>).addAttribute(<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="string">&quot;com.github.vianlex.dao.UserDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(document.asXML());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot; ============================================== &quot;</span>);</span><br><span class="line"><span class="comment">// 美化打印 xml</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">OutputFormat</span> <span class="variable">format</span> <span class="operator">=</span> OutputFormat.createPrettyPrint();</span><br><span class="line"><span class="type">XMLWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLWriter</span>(System.out, format);</span><br><span class="line">writer.write(document);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot; ============================================== &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧凑型打印 xml</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Compact format to System.out</span></span><br><span class="line"><span class="type">OutputFormat</span> <span class="variable">format</span> <span class="operator">=</span> OutputFormat.createCompactFormat();</span><br><span class="line"><span class="type">XMLWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLWriter</span>(System.out, format);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="将文本-xml-写文件"><a href="#将文本-xml-写文件" class="headerlink" title="将文本 xml 写文件"></a>将文本 xml 写文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;foo.xml&quot;</span>);</span><br><span class="line">document.write(out);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h2 id="解析-XML"><a href="#解析-XML" class="headerlink" title="解析 XML"></a>解析 XML</h2><ol><li><p>解析文本 xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDocumentByText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;beans&gt;&lt;bean id=\&quot;userService\&quot; class=\&quot;com.github.vianlex.service.impl.UserServiceImpl\&quot;&gt;&lt;property name=\&quot;userDao\&quot; ref=\&quot;userDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleService\&quot; class=\&quot;com.github.vianlex.service.impl.RoleServiceImpl\&quot;&gt;&lt;property name=\&quot;roleDao\&quot; ref=\&quot;roleDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleDao\&quot; class=\&quot;com.github.vianlex.dao.RoleDao\&quot;/&gt;&lt;bean id=\&quot;userDao\&quot; class=\&quot;com.github.vianlex.dao.UserDao\&quot;/&gt;&lt;/beans&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span>  DocumentHelper.parseText(xml);</span><br><span class="line">        System.out.println(document.asXML());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;解析文本 xml 出错&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>解析文件中的 xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDocumentByXmlFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;spring-context.xml&quot;</span>;</span><br><span class="line">    <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="built_in">this</span>.getClass().getResourceAsStream(fileName));</span><br><span class="line">        System.out.println(document.asXML());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;解析 xml 文件出错&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="解析-document"><a href="#解析-document" class="headerlink" title="解析 document"></a>解析 document</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代方式解析 document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseDocumentByIter</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;beans id=\&quot;helloRoot\&quot;&gt;&lt;bean id=\&quot;userService\&quot; class=\&quot;com.github.vianlex.service.impl.UserServiceImpl\&quot;&gt;&lt;property name=\&quot;userDao\&quot; ref=\&quot;userDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleService\&quot; class=\&quot;com.github.vianlex.service.impl.RoleServiceImpl\&quot;&gt;&lt;property name=\&quot;roleDao\&quot; ref=\&quot;roleDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleDao\&quot; class=\&quot;com.github.vianlex.dao.RoleDao\&quot;/&gt;&lt;bean id=\&quot;userDao\&quot; class=\&quot;com.github.vianlex.dao.UserDao\&quot;/&gt;&lt;/beans&gt;&quot;</span>;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span>  DocumentHelper.parseText(xml);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root elements</span></span><br><span class="line">    <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through child elements of root</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Element&gt; it = root.elementIterator(); it.hasNext();) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;元素标签名：&quot;</span>+element.getName()+<span class="string">&quot;，标签属性：(id = &#x27;&quot;</span>+element.attributeValue(<span class="string">&quot;id&quot;</span>) +<span class="string">&quot;&#x27;, class=&#x27;&quot;</span>+element.attributeValue(<span class="string">&quot;class&quot;</span>)+<span class="string">&quot;&#x27;)&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot; ================================================= &quot;</span>);</span><br><span class="line">    <span class="comment">// iterate through child elements of root with element name &quot;bean&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Element&gt; it = root.elementIterator(<span class="string">&quot;bean&quot;</span>); it.hasNext();) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;元素标签名：&quot;</span>+element.getName()+<span class="string">&quot;，标签属性：(id = &#x27;&quot;</span>+element.attributeValue(<span class="string">&quot;id&quot;</span>) +<span class="string">&quot;&#x27;, class=&#x27;&quot;</span>+element.attributeValue(<span class="string">&quot;class&quot;</span>)+<span class="string">&quot;&#x27;)&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot; ====================================== &quot;</span>);</span><br><span class="line">    <span class="comment">// iterate through attributes of root</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Attribute&gt; it = root.attributeIterator(); it.hasNext();) &#123;</span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">attribute</span> <span class="operator">=</span> it.next();</span><br><span class="line">        System.out.println(attribute.getName() + <span class="string">&quot; = &quot;</span> + attribute.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * xpath 方式解析 document</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseDocumentByXpath</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;beans&gt;&lt;bean id=\&quot;userService\&quot; class=\&quot;com.github.vianlex.service.impl.UserServiceImpl\&quot;&gt;&lt;property name=\&quot;userDao\&quot; ref=\&quot;userDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleService\&quot; class=\&quot;com.github.vianlex.service.impl.RoleServiceImpl\&quot;&gt;&lt;property name=\&quot;roleDao\&quot; ref=\&quot;roleDao\&quot;/&gt;&lt;/bean&gt;&lt;bean id=\&quot;roleDao\&quot; class=\&quot;com.github.vianlex.dao.RoleDao\&quot;/&gt;&lt;bean id=\&quot;userDao\&quot; class=\&quot;com.github.vianlex.dao.UserDao\&quot;/&gt;&lt;/beans&gt;&quot;</span>;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span>  DocumentHelper.parseText(xml);</span><br><span class="line">    <span class="comment">// 查找 &lt;bean&gt; 元素</span></span><br><span class="line">    List&lt;Node&gt; beanNodeList = document.selectNodes(<span class="string">&quot;//bean&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Node node : beanNodeList) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        System.out.println(element.getName()+ <span class="string">&quot;, &quot;</span> + element.attributeValue(<span class="string">&quot;id&quot;</span>) + element.attributeValue(<span class="string">&quot;class&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 &lt;property&gt; 元素</span></span><br><span class="line">    List&lt;Node&gt; propertyNodeList = document.selectNodes(<span class="string">&quot;//property&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Node node : propertyNodeList) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        System.out.println(element.getName()+ <span class="string">&quot;, &quot;</span> + element.attributeValue(<span class="string">&quot;name&quot;</span>) + element.attributeValue(<span class="string">&quot;ref&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://dom4j.github.io/#top">https://dom4j.github.io/#top</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven-引入依赖包&quot;&gt;&lt;a href=&quot;#Maven-引入依赖包&quot; class=&quot;headerlink&quot; title=&quot;Maven 引入依赖包&quot;&gt;&lt;/a&gt;Maven 引入依赖包&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="Xml" scheme="http://example.com/categories/Xml/"/>
    
    
  </entry>
  
  <entry>
    <title>XPath 笔记</title>
    <link href="http://example.com/wiki/Xml/XPath%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/Xml/XPath%20%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XPath-节点术语"><a href="#XPath-节点术语" class="headerlink" title="XPath 节点术语"></a>XPath 节点术语</h2><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。</p><h2 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h2><ul><li>父（Parent）， 每个元素以及属性都有一个父节点。</li><li>子（Children）, 元素节点可有零个、一个或多个子节点。</li><li>同胞（Sibling），拥有相同的父的节点。</li><li>先辈（Ancestor），某节点的父节点、及父父节点，等等。</li><li>后代（Descendant），某个节点的子节点，及子子节点，等等。</li></ul><h2 id="XPath-语法"><a href="#XPath-语法" class="headerlink" title="XPath 语法"></a>XPath 语法</h2><p>示例语法 XML 实例文档，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>表达式</td><td>描述</td></tr><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>&#x2F;</td><td>表示文档树的起始</td></tr><tr><td>&#x2F;&#x2F;</td><td>匹配文档中的任何节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table><p>使用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文档中的 bookstore 节点</span></span><br><span class="line">/bookstore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文档 bookstore 节点下的 book 节点</span></span><br><span class="line">/bookstore/book</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文档中的所有 book 节点</span></span><br><span class="line">//book</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文档中的所有 title 节点 </span></span><br><span class="line">//title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取名为 lang 的所有属性</span></span><br><span class="line">//@lang</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="谓语选择"><a href="#谓语选择" class="headerlink" title="谓语选择"></a>谓语选择</h2><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中使用。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>&#x2F;bookstore&#x2F;book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[position()&lt;3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>&#x2F;&#x2F;title[@lang]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>&#x2F;&#x2F;title[@lang&#x3D;’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><h2 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h2><p>XPath 通配符可用来选取未知的 XML 元素。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>通配符</td><td>描述</td></tr><tr><td>*</td><td>匹配任何元素节点。如 &#x2F;&#x2F;book&#x2F;*，选取 book 节点下面的所有节点，如 <code>//*</code>，选择文档中的所有元素。</td></tr><tr><td>@*</td><td>匹配任何属性节点。如 &#x2F;&#x2F;title[@*] 选取所有带有属性的 title 元素</td></tr><tr><td>node()</td><td>匹配任何类型的节点。如 &#x2F;bookstore&#x2F;node() 选取 bookstore 节点下的任何节点</td></tr></tbody></table><h2 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h2><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>路径表达式结果</td><td></td></tr><tr><td>&#x2F;&#x2F;book&#x2F;title</td><td>&#x2F;&#x2F;book&#x2F;price选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td>&#x2F;&#x2F;title</td><td>&#x2F;&#x2F;price选取文档中的所有 title 和 price 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book&#x2F;title</td><td>&#x2F;&#x2F;price选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><h2 id="XPath-轴"><a href="#XPath-轴" class="headerlink" title="XPath 轴"></a>XPath 轴</h2><p>轴可定义相对于当前节点的节点集。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>轴名称</td><td>结果</td></tr><tr><td>ancestor选取当前节点的所有先辈（父、祖父等）。</td><td></td></tr><tr><td>ancestor-or-self选取当前节点的所有先辈（父、祖父等）以及当前节点本身。</td><td></td></tr><tr><td>attribute选取当前节点的所有属性。</td><td></td></tr><tr><td>child选取当前节点的所有子元素。</td><td></td></tr><tr><td>descendant选取当前节点的所有后代元素（子、孙等）。</td><td></td></tr><tr><td>descendant-or-self选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td><td></td></tr><tr><td>following选取文档中当前节点的结束标签之后的所有节点。</td><td></td></tr><tr><td>namespace选取当前节点的所有命名空间节点。</td><td></td></tr><tr><td>parent选取当前节点的父节点。</td><td></td></tr><tr><td>preceding选取文档中当前节点的开始标签之前的所有节点。</td><td></td></tr><tr><td>preceding-sibling选取当前节点之前的所有同级节点。</td><td></td></tr><tr><td>self选取当前节点。</td><td></td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.w3school.com.cn/xpath/index.asp">https://www.w3school.com.cn/xpath/index.asp</a></li><li><a href="https://extendsclass.com/xpath-tester.html#sample">在线测试地址</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XPath-节点术语&quot;&gt;&lt;a href=&quot;#XPath-节点术语&quot; class=&quot;headerlink&quot; title=&quot;XPath 节点术语&quot;&gt;&lt;/a&gt;XPath 节点术语&lt;/h2&gt;&lt;p&gt;在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、</summary>
      
    
    
    
    <category term="Xml" scheme="http://example.com/categories/Xml/"/>
    
    
  </entry>
  
  <entry>
    <title>软件名称记录</title>
    <link href="http://example.com/wiki/other/%E8%BD%AF%E4%BB%B6%E5%90%8D%E7%A7%B0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/wiki/other/%E8%BD%AF%E4%BB%B6%E5%90%8D%E7%A7%B0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<p>1、常见软件名后缀 CE、EE、CS 的说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-ce  表示的是 docker 社区版(Community Edition)</span><br><span class="line">docker-ee  表示的是 docker 企业版(Enterprise Edition)</span><br><span class="line">docker-cs  表示的是 docker 自定义版(Custom Support)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、常见软件名后缀 CE、EE、CS 的说明&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    <category term="other" scheme="http://example.com/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>网络设备入门笔记</title>
    <link href="http://example.com/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.114Z</published>
    <updated>2023-05-31T13:39:26.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机的作用是通过网线将多台计算机形成一个局域网， 交换机是在集线器的基础上优化而来，集线器的工作原理是把接收到的数据包通过广播的方式发送给插入集线器的所有计算机，在整个局域网中的所有计算机都会接收到这个数据包，并且判断数据包是否发送给自己的，如果是就接收，不是就丢掉。当局域网很小的时候，用集线器问题不大，但是当局域网的设备比较多的时候，每个计算机发的包都广播给集线器的所有端口，网络线路就会很频繁，形成网络风暴，性能就不好了。集线器是无脑的广播数据包，而交换机则更加智能化，交换机传输数据包会直接传输到指定的端口上去，不会每次都广播给所有端口。<br>交换机里面保存了一张 MAC 的地址表，记录计算机(或者其他设备)的 MAC 地址以及其插入交换机的端口位置，当交换机接受到数据包时，会根据数据包中的 MAC 地址在地址表中找到对应的端口，然后将数据包该端口转发到对应的计算中，所有就不需要将数据包广播给所有端口了。如果地址表中没有对应的记录，则将数据包广播到除了源端口之外的所有端口，然后把响应的端口写到地址表中。如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。<br><img src="/images/%E7%BD%91%E7%BB%9C-%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="网络-交换机"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器就是用来连接两个或多个不同的局域网的。路由器是基于网络层设计的，提供了路由与转发两种重要的机制，每个路由器中都有一个路由表和转发表，路由表用来决策路由，转发表用来转发分组。路由器收到一个数据包后，会检查其目的 IP 地址，然后查找路由表。查找到匹配的路由表项之后，路由器会根据该表项所指示的出接口信息和下一跳信息将数据包转发出去。</p><p><img src="/images/%E7%BD%91%E7%BB%9C-%E8%B7%AF%E7%94%B1%E5%99%A8.png" alt="网络-路由器"></p><h2 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h2><ul><li>交换机工作于数据链路层，能识别 MAC 地址，根据 MAC 地址转发链路层数据帧，路由器位于网络层，能识别 IP 地址，根据 IP 地址转发分组；</li><li>交换机用于连接局域网，数据包在局域网内网的数据转发，路由器用于连接局域网和外网，数据包可以在不同局域网转发。</li></ul><h2 id="NAT-网络"><a href="#NAT-网络" class="headerlink" title="NAT 网络"></a>NAT 网络</h2><p>NAT 英文全称 Network Address Translation，中文翻译为网络地址转换，它是一种把内部私有网络地址转换成上一级对外输出的网络IP地址。虚拟系统借助 NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p><h2 id="虚拟网络"><a href="#虚拟网络" class="headerlink" title="虚拟网络"></a>虚拟网络</h2><h3 id="虚拟网桥-Bridge"><a href="#虚拟网桥-Bridge" class="headerlink" title="虚拟网桥(Bridge)"></a>虚拟网桥(Bridge)</h3><p>虚拟网桥可以看作是一个虚拟的交换机，可以配置 MAC 和 IP 地址，可以使用 veth-pair 虚拟设备(相当于网线)或者虚拟网卡 tun&#x2F;tap 将不同的虚拟机连接到虚拟交换机组成一个虚拟的局域网(VLAN)。如果把网桥、虚拟机网段设置跟宿主机的同一个网段，则虚拟局域网跟宿主机局域网属于平行关系，那么在网络上可以把虚拟机看成一台真正的主机，如果网桥配置的网关跟宿主机不一样，则虚拟局域网跟宿主机的局域网属于两个隔开的网络，如果虚拟机想要通过宿主机访问外网，则需要宿主机开启 开启 IP forward 功能并配置 NAT 地址转换，才能连接到外网。Linux 可以使用 <code>brcti</code> 命令可以操作虚拟的网络。<br><img src="/images/%E8%99%9A%E6%8B%9F%E7%BD%91%E6%A1%A5.png" alt="虚拟网桥"></p><h3 id="虚拟-NAT"><a href="#虚拟-NAT" class="headerlink" title="虚拟 NAT"></a>虚拟 NAT</h3><p>虚拟 NAT 会在宿主机中虚拟出一块网卡来，使得宿主机成为双网卡主机，虚拟网卡带有 NAT 功能，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。虚拟 NAT 的缺点是虚拟机可以 ping 通宿主机，但是宿主机 ping 不通虚拟机。</p><h3 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only"></a>Host-only</h3><p>在 Host-Only 模式下，虚拟网络是一个全封闭的网络，只能能够与宿主机通信。 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到通过宿主机连到外网，Host-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="https://blog.csdn.net/qq_21187515/article/details/119375576">https://blog.csdn.net/qq_21187515/article/details/119375576</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;交换机&quot;&gt;&lt;a href=&quot;#交换机&quot; class=&quot;headerlink&quot; title=&quot;交换机&quot;&gt;&lt;/a&gt;交换机&lt;/h2&gt;&lt;p&gt;交换机的作用是通过网线将多台计算机形成一个局域网， 交换机是在集线器的基础上优化而来，集线器的工作原理是把接收到的数据包通过广播的方</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Excel 设置行高和换行问题</title>
    <link href="http://example.com/wiki/Apache%20POI/Excel%20%E8%AE%BE%E7%BD%AE%E8%A1%8C%E9%AB%98%E5%92%8C%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/wiki/Apache%20POI/Excel%20%E8%AE%BE%E7%BD%AE%E8%A1%8C%E9%AB%98%E5%92%8C%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Excel-单元格设置强制换行，使用符号-r-n-可以强制换行"><a href="#Excel-单元格设置强制换行，使用符号-r-n-可以强制换行" class="headerlink" title="Excel 单元格设置强制换行，使用符号 \r\n 可以强制换行"></a>Excel 单元格设置强制换行，使用符号 \r\n 可以强制换行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单元格数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;假如生活欺骗了你，不要悲伤，不要心急！忧郁的日子里需要镇静，相信吧，快乐的日子将会来临。&quot;</span></span><br><span class="line"><span class="comment">// 创建行</span></span><br><span class="line"><span class="type">Row</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置默认的行高</span></span><br><span class="line">row.setHeight(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 创建样式</span></span><br><span class="line"><span class="type">HSSFCellStyle</span> <span class="variable">style</span> <span class="operator">=</span> workbook.createCellStyle();</span><br><span class="line">style.setWrapText(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 创建单元格</span></span><br><span class="line"><span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> row.createCell(<span class="number">0</span>);</span><br><span class="line">cell.setCellStyle(style);</span><br><span class="line"><span class="comment">//设置默认的列宽</span></span><br><span class="line">sheet.setDefaultColumnWidth(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 强制实现换行 data</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sbData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(data)</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sbData.length();</span><br><span class="line"><span class="type">int</span> <span class="variable">rowHeightLine</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> width - <span class="number">1</span>; i &lt; length; i = i + width + <span class="number">1</span> ) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;换行符位置：&quot;</span> + i);</span><br><span class="line">    sbData.insert(i, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    rowHeightLine++;</span><br><span class="line">&#125;</span><br><span class="line">row.setHeight(row.getHeight() * rowHeightLine)</span><br><span class="line">cell.setCellValue(sbData.toString());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/19145628/auto-size-height-for-rows-in-apache-poi#">https://stackoverflow.com/questions/19145628/auto-size-height-for-rows-in-apache-poi#</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Excel-单元格设置强制换行，使用符号-r-n-可以强制换行&quot;&gt;&lt;a href=&quot;#Excel-单元格设置强制换行，使用符号-r-n-可以强制换行&quot; class=&quot;headerlink&quot; title=&quot;Excel 单元格设置强制换行，使用符号 &#92;r&#92;n 可以强制</summary>
      
    
    
    
    <category term="Apache POI" scheme="http://example.com/categories/Apache-POI/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker Swarm 笔记</title>
    <link href="http://example.com/wiki/Docker/Docker%20Swarm%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/Docker/Docker%20Swarm%20%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swarm-介绍"><a href="#Swarm-介绍" class="headerlink" title="Swarm 介绍"></a>Swarm 介绍</h2><p>Swarm 是多个以 Swarm Mode 运行的 Docker 主机组成的集群，Swarm 集群中的 Docker 主机可以充当管理节点（Manager）、工作节点（Worker）或者两者都可以。</p><ul><li>管理节点：主要负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li><li>工作节点：主要负责执行运行服务的任务。<br><img src="/images/docker-swarm.png" alt="Swarm架构图"></li></ul><h2 id="Swarm-基本概念"><a href="#Swarm-基本概念" class="headerlink" title="Swarm 基本概念"></a>Swarm 基本概念</h2><p>Swarm 集群管理涉及的抽象对象有三个分别是 Node、Task、Service。</p><ul><li>节点(node)：Swarm 的管理节点(manager)和工作节点(worker)的统称。</li><li>任务(Task)： Task 是 Swarm 中的最小的调度单位，一个运行的容器就是一个 Task。</li><li>服务(Service)：Service 是由一组 Task 组成构成。可以把 Task 看作是 k8s 的 Pod，Service 相当于 K8s 的 Deployment 等工作负载。Service 又分为以下两种：<ol><li>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</li><li>global services 每个工作节点上都会运行 Service 中的任务。</li></ol></li><li>负载均衡(Load balancing)：Swarm 通过 ingress 负载均衡暴露 Service 外部访问。如果你没有定义端口，则 Swarm 会默认暴露 30000-32767 范围内的一个端口。当有请求访问服务时，Swarm 通过内部的负载均衡将请求分发到相应的 Task 中。</li></ul><p>注意：当你通过 Docker Swarm 创建一个 service 时，你定义了它的理想状态（副本数、网络、存储资源、对外暴露的端口等）。Docker会维持它的状态，例如，如果一个 worker node 不可用了，Docker Swarm 会调度不可用 node 上的 task 到其他 nodes 上。运行在容器中的一个 task，是 swarm service 的一部分，且通过 swarm manager 进行管理和调度，和独立的容器是截然不同的。Swarm service 相比单容器的一个最大优势就是，你能够修改一个服务的配置：包括网络、数据卷，不需要手工重启服务。Docker 将会更新配置，把过期配置的 task 停掉，重新创建一个新配置的容器。</p><h2 id="Swarm-节点管理"><a href="#Swarm-节点管理" class="headerlink" title="Swarm 节点管理"></a>Swarm 节点管理</h2><ol><li>查看节点信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node <span class="built_in">ls</span> </span><br></pre></td></tr></table></figure></li><li>获取添加工作节点或者管理节点的 token<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取加入工作节点的 token</span></span><br><span class="line"> docker swarm join-token worker</span><br><span class="line"><span class="comment"># 管理节点</span></span><br><span class="line"> docker swarm join-token manager</span><br></pre></td></tr></table></figure></li><li>节点脱离 swarm 集群<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- force 表示强制离开集群</span></span><br><span class="line">docker swarm leave [--force]</span><br></pre></td></tr></table></figure></li><li>删除集群某个节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node remove &lt;节点名称|节点ID&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>通过 <code>docker service create</code>命令可以快速部署服务，该命令语法格式为：<code>docker service create &lt;--name 服务名字&gt; &lt;--replicas task副本数&gt; &lt;image&gt; [容器运行后要执行的命令]</code>，常用可选参数如下：</p><ul><li>–name 指定服务的名字</li><li>–replicas 指定 Task 的副本数量</li><li>-w, –workdir 指定容器的工作目录</li><li>env 指定环境变量，如<code> -env JAVA_OPS=&quot;&quot;</code></li><li>–mount 容器目录挂载到主机目录，如：<code>--mount host/xxx/xxx:container/xxx/xxx</code> 或者 <code>--mount type=bind,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt; </code>，推荐使用第二种新语法，比较明了</li><li>-p, –publish port 指定端口，如：<code>-p host-port:container-port</code> 或者 <code>--publish published=&lt;host-port&gt;,target=&lt;container-port&gt;</code>，推荐使用第二种新语法，比较明了</li><li>–update-delay 设置滚动更新延迟时间，即为多个副本任务的更新间隔时间</li><li>–update-parallelism 每次并发更新的任务数量</li><li>–mode 指定服务的运行模式可选值有：replicated(按一定规则调度 task 到合适的 node), global(每个工作节点都运行一个 task), replicated-job, global-job</li></ul><ol><li><p>创建服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创一个名 test-swarm 的服务，运行2个副本任务容器</span></span><br><span class="line">docker service create --name test-swarm  -p 2000:80  --replicas 2 nginx:latest</span><br><span class="line"></span><br><span class="line"> endpoint_mode=dnsrr</span><br></pre></td></tr></table></figure></li><li><p>查看正在运行的 services，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span> </span><br></pre></td></tr></table></figure></li><li><p>查看 service 信息，使用命令 <code>docker service inspect --pretty &lt;服务名&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看名为 test-swarm 的 service 详细信息</span></span><br><span class="line">docker service inspect --pretty test-swarm</span><br></pre></td></tr></table></figure></li><li><p>使用命令<code>docker service ps &lt;服务名&gt;</code>查看服务 Task 的运行信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看 test-swarm 服务中 task 的运行情况   </span><br><span class="line">docker service ps test-swarm</span><br></pre></td></tr></table></figure></li><li><p>使用命令<code>docker service update &lt;选项参数&gt; &lt;服务名&gt;</code>，具体支持哪些配置的更新改动可以使用帮助命令查看 <code>docker serivce update --help </code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增 3000:80 端口映射</span></span><br><span class="line">docker service update --publish-add 3000:80</span><br><span class="line"><span class="comment"># 删除端口映射</span></span><br><span class="line">docker service update --publish-rm 3000:80</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>扩容增加任务副本数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 test-swarm 服务的任务副本数量修改为 3</span></span><br><span class="line">docker service scale test-swarm=3</span><br><span class="line"><span class="comment"># 等同以上命令</span></span><br><span class="line">docker service update --replicas 3 test-swarm</span><br></pre></td></tr></table></figure></li><li><p>删除服务，使用命令 <code>docker service rm &lt;服务名&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 test-swarm 服务</span></span><br><span class="line">docker service <span class="built_in">rm</span> test-swarm</span><br></pre></td></tr></table></figure></li><li><p>查看服务的日志，使用命令 <code>docker service logs [OPTIONS] &lt;SERVICE|TASK&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看服务 test-swarm 的日志</span></span><br><span class="line">docker service logs -f --<span class="built_in">tail</span>=200 test-swarm</span><br></pre></td></tr></table></figure></li></ol><h2 id="部署多个服务"><a href="#部署多个服务" class="headerlink" title="部署多个服务"></a>部署多个服务</h2><p>批量部署多个服务需要使用 docker stack 命令和 docker-compose.yaml 配置文件，docker stack 是 docker serice 在基础上封装了一层，一个 stack 管理着多个 serivces，docker stack 常用命令如下：</p><ul><li>docker stack deploy 部署或者更新 stack </li><li>docker stack ls 查看已部署的 stack 列表</li><li>docker stack ps 查看 stack 部署的服务下的任务列表  </li><li>docker stack rm 删除一个 stack</li><li>docker stack services 查看 stack 部署的所有服务</li></ul><ol><li><p>定义 stack 使用的 docker-compose 文件，<a href="https://docs.docker.com/compose/compose-file">配置说明</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span> <span class="comment"># 容器端口 </span></span><br><span class="line">        <span class="attr">published:</span> <span class="number">8080</span> <span class="comment"># 主机端口</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">tcp</span> <span class="comment"># 可选值 tcp、udp</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">ingress</span> <span class="comment"># 可选值 host、ingress 默认 ingress</span></span><br><span class="line">    <span class="comment"># 注意如果没有配置 deploy 属性的话，ports 属性中 mode 配置的 ingress 模式是不起作用的，会模式为 host 模式</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span> <span class="comment"># 可选值 replicated 和 global 默认值 replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 配置服务副本数量</span></span><br><span class="line">      <span class="attr">endpoint_mode:</span> <span class="string">vip</span> <span class="comment"># 配置服务发现模式，可选值 vip 和 dnsrr, 默认值 vip</span></span><br><span class="line">      <span class="comment"># 配置重启策略</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">120s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>docker stack deploy</code> 命令部署服务，命令语法 <code>docker stack deploy [OPTIONS] STACK(表示 stack 名)</code>，常用选项如下：</p></li></ol><ul><li>–compose-file , -c 指定 docker-compose 配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 docker-compose 配置文件部署一个名为 mystack 的 stack，部署后生成的服务名格式为：stack 名 + docker-compose 文件配置的服务名，即 mystack_my-web</span></span><br><span class="line">docker stack -c docker-compose.yml mystack </span><br></pre></td></tr></table></figure></li></ul><h2 id="服务发现和负载均衡"><a href="#服务发现和负载均衡" class="headerlink" title="服务发现和负载均衡"></a>服务发现和负载均衡</h2><p>Service 相当于它的所有 Task 的一个反向代理，Service 的服务发现和负载均衡是利用 Linux 内核的 iptables 和 IPVS 的功能来实现。Docker Swarm 提供了两种不同机制的服务发现，分别是：</p><ul><li>VIP(Virtual IP)：Swarm 创建应用服务时，会创建一个应用服务的虚拟 IP，Docker 内嵌的 DNS 服务会维护该虚拟 IP 和应用服务名记录，同时在每个应用服务容器内创建一个 ingress_sbox 网络命令空间，然后利用 Linux 内核的 iptables 和 IPVS 在 ingress_sbox 网络命名空间通过 VIP 转发请求到服务容器的 IP，从而实现负载均衡。 </li><li>DRR(DNS round-robin)：通过 Docker 引擎提供的内嵌 DNS 服务，维护服务名对应 task 容器的 IP 地址列表，当前请求访问服务时，Docker DNS 解析服务名，获取服务所有任务容器的 IP 地址列表，然后将请求转发到其中任意一个(一般默认是第一)，从而实现负载均衡。</li></ul><p>Docker Swarm 通过  ingress overlay 网络实现了网格路由(routing mesh)功能。在 Swarm 集群中所有的工作节点(worker)和管理节点(manager)都会参与到网格路由中。当部署的服务通过 <code>--publish</code> 暴露端口时，由于所有的节点都在网格路由(routing mesh)中，所以全部的节点都会是监听<code>--publish</code>暴露的端口，因此访问集群中的任何节点都可以访问到服务。 如果不想每个节点都监听服务暴露的端口，则需要将暴露的模式指定为 host 模式，来禁用路由网格，如 <code>--publish published=8080,target=80,mode=host </code>。<br><img src="/images/docker-swarm%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1.png" alt="网格路由"></p><p>路由网格模式只支持 VIP 的服务发现模式，如果使用 DRR 模式是不起作用的。可以通过 <code>--endpoint_mode: vip | drr</code> 指定服务选择那种服务发现，默认是 vip</p><h2 id="管理节点和工作节点的心跳"><a href="#管理节点和工作节点的心跳" class="headerlink" title="管理节点和工作节点的心跳"></a>管理节点和工作节点的心跳</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改检测心跳1分钟</span></span><br><span class="line">docker swarm update --dispatcher-heartbeat 60s</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/">https://docs.docker.com/engine/swarm/swarm-tutorial/</a></li><li><a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/">https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/</a></li><li><a href="https://docs.docker.com/engine/swarm/networking/">https://docs.docker.com/engine/swarm/networking/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Swarm-介绍&quot;&gt;&lt;a href=&quot;#Swarm-介绍&quot; class=&quot;headerlink&quot; title=&quot;Swarm 介绍&quot;&gt;&lt;/a&gt;Swarm 介绍&lt;/h2&gt;&lt;p&gt;Swarm 是多个以 Swarm Mode 运行的 Docker 主机组成的集群，Swarm</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 入门笔记</title>
    <link href="http://example.com/wiki/Docker/Docker%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/Docker/Docker%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-Docker-网络原理"><a href="#2-Docker-网络原理" class="headerlink" title="2. Docker 网络原理"></a>2. Docker 网络原理</h2><p>Docker 服务进程启动时，默认会创建一个 docker0 虚拟网桥，也就是虚拟交换机，docker0 的默认 IP 地址为172.17.0.1，子网掩码为255.255.0.0。<br>在 Linux 系统中可以使用命令 <code>brctl show</code> 可以查看虚拟网桥，如果命令不存在，需要安装 <code>bridge-utils</code> 软件。</p><h3 id="2-1-Docker-网络模式"><a href="#2-1-Docker-网络模式" class="headerlink" title="2.1 Docker 网络模式"></a>2.1 Docker 网络模式</h3><p>Docker 默认支持4种网络工作模式，如下：</p><ul><li>Host 模式：容器内部网络空间共享主机的空间，效果类似直接在宿主机上启动一个进程，端口信息和宿主机共用；</li><li>Container 模式：启动时使用参数 -net &#x3D; container:[名称|id] 指定当前启动容器与 -net 指定的已存在的容器共享网络，使用其网络命名空间。</li><li>None 模式：该模式关闭了容器的网络功能，但是还会保留网络命名空间，只是不创建虚拟网卡和相关网络配置。</li><li>Bridge 模式：该模式是 Docker 默认网络模式，容器启动时会将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及宿主机 Iptables nat 表配置与宿主机通信。</li></ul><h4 id="2-1-1-Container-模式"><a href="#2-1-1-Container-模式" class="headerlink" title="2.1.1 Container 模式"></a>2.1.1 Container 模式</h4><h4 id="2-1-2-Bridge-模式"><a href="#2-1-2-Bridge-模式" class="headerlink" title="2.1.2 Bridge 模式"></a>2.1.2 Bridge 模式</h4><p>Bridge 网桥是虚拟交换机，工作于数据链路层，主要的功能是根据 MAC 地址将数据包转发到网桥的不同端口上。Docker 网桥模式的示意图如下：<br><img src="/images/docker-%E7%BD%91%E6%A1%A5%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="docker-网桥模式示意图"></p><p>Docker 创建启动一个容器的时候，会在宿主机中创建一对虚拟接口&#x2F;网卡 Veth Pair，虚拟端口的一端桥接到 docker0 网桥，在宿主机中使用 <code>ifconfig | grep veth </code> 可以查看到，其命名的方式前缀固定 Veth 后缀随机，如 veth080517f，虚拟端口的另一端连接到新启动的容器内部网络中，因为容器内跟宿主机的网络命名空间是隔离的，所其名字会被命名给 eth0，然后从网桥的可用地址段中获取一个空闲地址分配给容器的 eth0。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="https://blog.csdn.net/m0_49654228/article/details/117446963">https://blog.csdn.net/m0_49654228/article/details/117446963</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-Docker-网络原理&quot;&gt;&lt;a href=&quot;#2-Docker-网络原理&quot; class=&quot;headerlink&quot; title=&quot;2. Docker 网络原理&quot;&gt;&lt;/a&gt;2. Docker 网络原理&lt;/h2&gt;&lt;p&gt;Docker 服务进程启动时，默认会创建一个 d</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="http://example.com/wiki/Docker/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/wiki/Docker/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-镜像查看、删除等相关命令"><a href="#docker-镜像查看、删除等相关命令" class="headerlink" title="docker 镜像查看、删除等相关命令"></a>docker 镜像查看、删除等相关命令</h2><h3 id="1-docker-images-命令查看本地镜像仓库中的镜像"><a href="#1-docker-images-命令查看本地镜像仓库中的镜像" class="headerlink" title="1. docker images 命令查看本地镜像仓库中的镜像"></a>1. docker images 命令查看本地镜像仓库中的镜像</h3><p>docker images 语法格式 <code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code>，可选参数如下：</p><ul><li>docker images -a列出本地所有的镜像</li><li>docker images -f 过滤查询镜像</li><li>docker images -q列出显示镜像 ID<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有镜像</span></span><br><span class="line">docker images </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 &lt;REPOSITORY&gt;[:TAG] 显式的过滤查看镜像，注意当使用 * 模糊匹配时，无法匹配 / 符号，如匹配 vianlex/nginx:dev-latest 镜像，支持以下方式匹配</span></span><br><span class="line">docker images vianlex/nginx</span><br><span class="line">docker images vianlex/nginx:dev-latest</span><br><span class="line">docker images <span class="string">&quot;*/nginx*&quot;</span></span><br><span class="line">docker images <span class="string">&quot;*/nginx:dev-*&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是查看镜像的 id</span></span><br><span class="line">docker images -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配标签(tag)为&lt;none&gt;的镜像</span></span><br><span class="line">docker images -f=<span class="string">&quot;dangling=true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 reference=&lt;REPOSITORY&gt;[:TAG] 模糊匹配镜像，注意匹配时，reference=&lt;REPOSITORY&gt;[:TAG] 中的 / 符号不能无法使用 * 模糊匹配，如匹配镜像 vianlex/nginx:dev-latest</span></span><br><span class="line">docker images -f=<span class="string">&quot;reference=*/nginx&quot;</span> 或者 docker images -f <span class="string">&quot;reference=*/nginx&quot;</span></span><br><span class="line">docker images -f=reference=<span class="string">&quot;*/nginx&quot;</span> 或者 docker images -f  reference=<span class="string">&quot;*/nginx&quot;</span> </span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">docker images -f=<span class="string">&quot;reference=*/nginx:dev-*&quot;</span></span><br><span class="line">docker images -f=reference=<span class="string">&quot;*/nginx:dev-*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 before 或者 since 过滤镜像，格式为 before=&lt;REPOSITORY&gt;[:TAG] 或者 before=image-id</span></span><br><span class="line">docker images -f before=<span class="string">&quot;eb4d124f64cd&quot;</span> <span class="comment"># 根据镜像 ID 查找创建时间大的镜像</span></span><br><span class="line">docker images -f since=<span class="string">&quot;vianlex/nginx:dev-latest&quot;</span> <span class="comment"># 根据镜像名称查找创建时间小的镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 label=&lt;key&gt; 或者 label=&lt;key&gt;=&lt;value&gt; 过滤镜像，label 是在 dockerfile 中定义的，可以使用 docker inpsect 命令可以查看镜像的 labels</span></span><br><span class="line">docker images -f=<span class="string">&quot;label=version&quot;</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">docker images -f=<span class="string">&quot;label=version=v1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式镜像列表的输出格式</span></span><br><span class="line">docker images --format <span class="string">&quot;&#123;&#123;.Repository&#125;&#125; -- &#123;&#123;.ID&#125;&#125; -- &#123;&#123;.Size&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker images --format <span class="string">&quot;&#123;&#123;.Repository&#125;&#125; &#123;&#123;.ID&#125;&#125; &#123;&#123;.Size&#125;&#125; &#123;&#123;.di&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">docker images --fotmat <span class="string">&quot;&#123;&#123;.ID&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-docker-rmi-命令删除-docker-镜像"><a href="#2-docker-rmi-命令删除-docker-镜像" class="headerlink" title="2. docker rmi 命令删除 docker 镜像"></a>2. docker rmi 命令删除 docker 镜像</h3><p>docker rmi 命令语法格式：<code>docker rmi [ repository:tag | imageId  ] </code>，可选参数 -f 指定强制删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据镜像仓库加标签删除 </span></span><br><span class="line">docker rmi nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据镜像 ID 删除</span></span><br><span class="line">docker rmi 43154ddb57a8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据镜像 id 批量删除 </span></span><br><span class="line">docker images -q | xargs docker rmi </span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"><span class="comment"># 删除 tag 是 none 的所有镜像</span></span><br><span class="line">docker rmi $(docker images -f <span class="string">&quot;dangling=true&quot;</span> -q)</span><br></pre></td></tr></table></figure><h2 id="docker-操作容器的常用命令"><a href="#docker-操作容器的常用命令" class="headerlink" title="docker 操作容器的常用命令"></a>docker 操作容器的常用命令</h2><h3 id="1-docker-run-命令"><a href="#1-docker-run-命令" class="headerlink" title="1. docker run 命令"></a>1. docker run 命令</h3><p>用于创建并启动 Docker 容器，常用参数如下：</p><ul><li>-d, –detach&#x3D;false 指定容器以后台进程的方式运行</li><li>-i, –interactive&#x3D;false 以交互模式运行容器，通常与 -t 同时使用</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>–name&#x3D;”myNginx”指定容器名字，方便管理</li><li>–dns 8.8.8.8 指定容器使用的 DNS 服务器，默认和宿主一致</li><li>–dns-search&#x3D; example.com 指定容器的 dns 搜索域名，会写入到容器的 &#x2F;etc&#x2F;resolv.conf 文件 </li><li>-h “linux-hostname” 指定容器的 hostname</li><li>-w, –workdir&#x3D;”&#x2F;opt” 指定容器的工作目录</li><li>-e username&#x3D;centeos, –env&#x3D;[] 设置容器的环境变量</li><li>–env-file&#x3D;[] 从指定文件读入环境变量</li><li>-v, –volume&#x3D;[]给容器挂载存储卷，挂载到容器的某个目录。</li><li>–dns&#x3D;[]指定容器的 dns 服务器。</li><li>-P 随机端口映射，容器内部端口随机映射到主机的端口</li><li>-p 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li>–entrypoint&#x3D;””覆盖 image 的入口点。</li><li>–env-file&#x3D;[]指定环境变量文件，文件格式为每行一个环境变量。</li><li>–expose&#x3D;[]指定容器暴露的端口，即修改镜像的暴露端口。</li><li>–link&#x3D;[]指定容器间的关联，使用其他容器的 IP、env 等信息。</li><li>-net&#x3D;”bridge”指定容器网络配置</li><li>–privileged&#x3D;false指定容器是否为特权容器，特权容器拥有所有的 capabilities。</li><li>–restart&#x3D;”no”指定容器停止后的重启策略:</li><li>–rm&#x3D;false指定容器停止后自动删除容器(不支持以 docker run -d 启动的容器)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建并启动 nginx 容器</span></span><br><span class="line">docker run -p 81:80  -v /data:/usr/share/nginx/html --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-docker-ps-查看容器"><a href="#2-docker-ps-查看容器" class="headerlink" title="2. docker ps 查看容器"></a>2. docker ps 查看容器</h3><p>常用的可选参数</p><ul><li>-q, –quiet 只显示容器的 ID</li><li>–format 格式化输出结果</li><li>-f, –filter 过滤显示结果，使用 key&#x3D;value 的方式过滤，如<code>-f name=myNginx</code>，可选的过值对如下：<ul><li>id 根据容器的 id 过滤</li><li>name 根据容器名称过滤</li><li>ancestor 根据镜像信息过滤，如 <code>-f ancestor &lt;image-name&gt;[:&lt;tag&gt;] | &lt;image id&gt;</code></li><li>status 根据状态进行过滤，可选值有 created, restarting, running, removing, paused, exited, or dead</li><li>publish or expose 根据端口过滤，如 <code>-f  publish &lt;port&gt;[/&lt;proto&gt;]</code> 或者 <code>-f  expose &lt;startport-endport&gt;/[&lt;proto&gt;] </code></li><li>before or since  根据创建时间或者容器名的前后过滤</li><li>label 根据标签过滤<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker ps --filter <span class="string">&quot;label=color&quot;</span></span><br><span class="line"></span><br><span class="line">docker ps --filter <span class="string">&quot;name=xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">docker ps --filter status=running</span><br><span class="line"></span><br><span class="line">docker ps --filter ancestor=nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示创建比容器 9c3527ed70ce 早的所有容器 </span></span><br><span class="line">docker ps -f before=9c3527ed70ce</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-docker-stop-停止正在运行的容易"><a href="#2-docker-stop-停止正在运行的容易" class="headerlink" title="2. docker stop 停止正在运行的容易"></a>2. docker stop 停止正在运行的容易</h3><p>docker stop 语法格式 <code>docker stop [--time , -t] container [container...]</code> 停止一个或者多个正在运行的容器，可选参数 -t 指定运行命令多少秒后停止容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据容器 id 停止容器</span></span><br><span class="line">docker stop 9c3527ed70ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据条件过滤停止容器</span></span><br><span class="line">docker stop  $(docker ps -q -f name=myNginx)</span><br></pre></td></tr></table></figure><h3 id="3-docker-start-启动容器"><a href="#3-docker-start-启动容器" class="headerlink" title="3. docker start 启动容器"></a>3. docker start 启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据容器名称或者id启动容器</span></span><br><span class="line">docker start [container-name|container-id]</span><br></pre></td></tr></table></figure><h3 id="4-docker-restart-者重启容器"><a href="#4-docker-restart-者重启容器" class="headerlink" title="4. docker restart 者重启容器"></a>4. docker restart 者重启容器</h3><p>可选参数 <code>--time, -t </code> 指定多少秒后停止并重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据容器 id 重启容器</span></span><br><span class="line">docker restart 9c3527ed70ce</span><br><span class="line">docker restart  $(docker ps -q -f name=myNginx)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-docker-rm-删除容器"><a href="#5-docker-rm-删除容器" class="headerlink" title="5. docker rm 删除容器"></a>5. docker rm 删除容器</h3><p>可以删除一个或者多个容器，可参数 -f 强制删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除容器，</span></span><br><span class="line">docker <span class="built_in">rm</span> [container-name|container-id]</span><br></pre></td></tr></table></figure><h3 id="6-docker-logs-查看容器运行日志"><a href="#6-docker-logs-查看容器运行日志" class="headerlink" title="6. docker logs 查看容器运行日志"></a>6. docker logs 查看容器运行日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看实时的日志：</span></span><br><span class="line">sudo docker logs -f --<span class="built_in">tail</span> 100  container_id 或者 container_name</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看指定时间后的日志，只显示最后100行：</span></span><br><span class="line">docker logs -f -t --since=<span class="string">&quot;2018-02-08&quot;</span> --<span class="built_in">tail</span>=100 container_id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看最近30分钟的日志:</span></span><br><span class="line">docker logs --since 30m container_id</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看某时间段日志：</span></span><br><span class="line">docker logs -t --since=<span class="string">&quot;2018-02-08T13:23:37&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2018-02-09T12:23:37&quot;</span> container_id</span><br></pre></td></tr></table></figure><h3 id="7-docker-exec-命令"><a href="#7-docker-exec-命令" class="headerlink" title="7. docker exec 命令"></a>7. docker exec 命令</h3><p>在宿主机运行容器中的命令，使用例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器的终端命令行</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [container_id | container_name] [/bin/sh | /bin/bash] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器的文件内容</span></span><br><span class="line">docker <span class="built_in">exec</span> [container_id | container_name]  <span class="built_in">cat</span> /logs/ils.2020-08-19.<span class="built_in">log</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器的命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [container_id | container_name] nginx -s reload </span><br></pre></td></tr></table></figure><h3 id="8-docker-cp-命令"><a href="#8-docker-cp-命令" class="headerlink" title="8. docker cp 命令"></a>8. docker cp 命令</h3><p>将容器中的文件复制到宿主机中或者将宿主机的文件复制容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器文件复制到宿主机中</span></span><br><span class="line">docker <span class="built_in">cp</span> [container_id | container_name]:/xxx/xxx  /home/xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将宿主机文件复制到容器中</span></span><br><span class="line">docker <span class="built_in">cp</span> /home/xxxxxx  [container_id | container_name]:/xxx/xxx</span><br></pre></td></tr></table></figure><h2 id="归档镜像导入导出"><a href="#归档镜像导入导出" class="headerlink" title="归档镜像导入导出"></a>归档镜像导入导出</h2><h3 id="1-docker-save-命令将-Docker-镜像保存成-tar-包"><a href="#1-docker-save-命令将-Docker-镜像保存成-tar-包" class="headerlink" title="1. docker save 命令将 Docker 镜像保存成 tar 包"></a>1. docker save 命令将 Docker 镜像保存成 tar 包</h3><p>docker save 命令语法 <code>docker save [ -o | --output | &gt; ]  filename.tar [ reposity:tag | imageId ]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种方式</span></span><br><span class="line">docker save -o flannel.tar rancher/mirrored-flannelcni-flannel:v0.20.0</span><br><span class="line"><span class="comment">#第二种方式</span></span><br><span class="line">docker save -o &gt; flannel-cni-plugin.tar fcecffc7ad4a</span><br></pre></td></tr></table></figure><h3 id="2-docker-load-命令将镜像归档文件导入镜像仓库"><a href="#2-docker-load-命令将镜像归档文件导入镜像仓库" class="headerlink" title="2. docker load 命令将镜像归档文件导入镜像仓库"></a>2. docker load 命令将镜像归档文件导入镜像仓库</h3><p>docker load 命令语法 <code>docker load [ --input | &lt; ] filename.tar</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">docker load --input filename.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">docker load &lt; filename.tar</span><br></pre></td></tr></table></figure><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><ol><li><a href="https://docs.docker.com/engine/reference/commandline/images/">https://docs.docker.com/engine/reference/commandline/images/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-镜像查看、删除等相关命令&quot;&gt;&lt;a href=&quot;#docker-镜像查看、删除等相关命令&quot; class=&quot;headerlink&quot; title=&quot;docker 镜像查看、删除等相关命令&quot;&gt;&lt;/a&gt;docker 镜像查看、删除等相关命令&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 权限配置</title>
    <link href="http://example.com/wiki/Docker/Docker%20%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/wiki/Docker/Docker%20%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新增-docker-用户组"><a href="#新增-docker-用户组" class="headerlink" title="新增 docker 用户组"></a>新增 docker 用户组</h2><p>查看 docker 用户组是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br></pre></td></tr></table></figure><p>docker 用户组不存在则新建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户组</span><br><span class="line">sudo groupadd docker</span><br><span class="line"># 给用户组设置权限</span><br><span class="line">sudo a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure><h2 id="将当前用户添加-docker-用户组"><a href="#将当前用户添加-docker-用户组" class="headerlink" title="将当前用户添加 docker 用户组"></a>将当前用户添加 docker 用户组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125;  docker</span><br></pre></td></tr></table></figure><h2 id="临时切换到-docker-组"><a href="#临时切换到-docker-组" class="headerlink" title="临时切换到 docker 组"></a>临时切换到 docker 组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newgrp  docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重启-docker-服务"><a href="#重启-docker-服务" class="headerlink" title="重启 docker 服务"></a>重启 docker 服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新增-docker-用户组&quot;&gt;&lt;a href=&quot;#新增-docker-用户组&quot; class=&quot;headerlink&quot; title=&quot;新增 docker 用户组&quot;&gt;&lt;/a&gt;新增 docker 用户组&lt;/h2&gt;&lt;p&gt;查看 docker 用户组是否存在&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Dockerfile 使用说明</title>
    <link href="http://example.com/wiki/Docker/Dockerfile%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/wiki/Docker/Dockerfile%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-构建忽略文件-dockerignore，指定构建上下文中可以复制哪些文件-文件格式如下"><a href="#docker-构建忽略文件-dockerignore，指定构建上下文中可以复制哪些文件-文件格式如下" class="headerlink" title="docker 构建忽略文件 .dockerignore，指定构建上下文中可以复制哪些文件, 文件格式如下"></a>docker 构建忽略文件 .dockerignore，指定构建上下文中可以复制哪些文件, 文件格式如下</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># * 表示忽略全部文件</span><br><span class="line">* </span><br><span class="line"># ! 表示可以排除哪些文件，不需要忽略 </span><br><span class="line">!package.json</span><br><span class="line">!nuxt.config.js </span><br><span class="line">!.nuxt </span><br><span class="line">!static </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="COPY-命令无法复制文件夹，则可以利用-dockerignore-来实现复制文件夹"><a href="#COPY-命令无法复制文件夹，则可以利用-dockerignore-来实现复制文件夹" class="headerlink" title="COPY 命令无法复制文件夹，则可以利用 .dockerignore 来实现复制文件夹"></a>COPY 命令无法复制文件夹，则可以利用 .dockerignore 来实现复制文件夹</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 比如想将 static 文件夹和其目录下的文件都复制到 /path 下，是无法实现的，COPY 只会将 static 目录中的文件复制到 /path 下，static 文件夹本身无法复制</span><br><span class="line">COPY static /path/</span><br><span class="line"></span><br><span class="line"># 这种方式可以复制文件夹，如将当前构建上下文中的文件，全部复制到 /path 目录下，COPY 命令会根据 .dockerignore 文件判断哪些文件可以复制，哪些文件不能复制</span><br><span class="line">COPY . /path/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker-构建忽略文件-dockerignore，指定构建上下文中可以复制哪些文件-文件格式如下&quot;&gt;&lt;a href=&quot;#docker-构建忽略文件-dockerignore，指定构建上下文中可以复制哪些文件-文件格式如下&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 安装笔记</title>
    <link href="http://example.com/wiki/Docker/docker%20%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/wiki/Docker/docker%20%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-YUM-命令安装"><a href="#使用-YUM-命令安装" class="headerlink" title="使用 YUM 命令安装"></a>使用 YUM 命令安装</h2><ol><li>安装 docker 依赖软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li>添加 docker 软件源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否 docker 软件源文件, 不存在，则用 wget 下载</span></span><br><span class="line"><span class="built_in">ls</span> -il /etc/yum.repos.d/docker-ce.repo </span><br><span class="line"><span class="comment"># 下载 docker 软件源文件，并保存到 /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li>安装 docker <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看可安装的版本 </span><br><span class="line">yum --showduplicates list docker-ce</span><br><span class="line"># 安装指定的版本</span><br><span class="line">yum -y install docker-ce-19.03.13-3.el8</span><br></pre></td></tr></table></figure></li><li>设置 docker 开机自启,并启动 docker<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure></li><li>查看 docker 版本，如果显示成功，表示安装成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure></li></ol><h2 id="CentOS8-使用-dnf-安装最新版"><a href="#CentOS8-使用-dnf-安装最新版" class="headerlink" title="CentOS8 使用 dnf 安装最新版"></a>CentOS8 使用 dnf 安装最新版</h2><ol><li>安装 Docker 存储驱动的依赖包，使用的 dnf 命令，centos8 开始使用dnf替代yum管理软件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install -y device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li>添加 Docker 软件源<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --add-repo=https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li>查看已添加的 Docker 软件源, 如果命令结果有返回 docker-ce.x86_64 说明添加成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf list docker-ce</span><br></pre></td></tr></table></figure></li><li>开始安装 Docker<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install -y docker-ce --nobest</span><br></pre></td></tr></table></figure></li><li>docker 启动相关命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重新加载配置文件</span></span><br><span class="line">systemctl daemon-reload   </span><br><span class="line"><span class="comment">#运行Docker守护进程</span></span><br><span class="line">systemctl start docker     </span><br><span class="line"><span class="comment">#停止Docker守护进程</span></span><br><span class="line">systemctl stop docker      </span><br><span class="line"><span class="comment">#重启Docker守护进程</span></span><br><span class="line">systemctl restart docker  </span><br><span class="line"><span class="comment">#设置Docker开机自启动 </span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker   </span><br></pre></td></tr></table></figure></li></ol><h2 id="手动离线安装"><a href="#手动离线安装" class="headerlink" title="手动离线安装"></a>手动离线安装</h2><ol><li>根据需要下载指定的 docker 安装包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://download.docker.com/linux/static/stable/x86_64/docker-19.03.10.tgz</span><br></pre></td></tr></table></figure></li><li>解压 docker 安装包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf docker-19.03.10.tgz</span><br></pre></td></tr></table></figure></li><li>将解压出来的 docker 目录复制或者移动到 &#x2F;usr&#x2F;bin 目录中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv docker /usr/bin/</span><br></pre></td></tr></table></figure></li><li>创建 docker.service 文件，并将文件复制到目录 <code>/etc/systemd/system/</code> 中，并添加可执行权限 <code>chmod +x  /etc/systemd/system/docker.service</code>，目的是使用 systemd 管理和控制 docker ，以守护进程的方式运行，方便设置开机自启。docker.service 的文件内容，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">BindsTo=containerd.service</span><br><span class="line">After=network-online.target firewalld.service containerd.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"># Note that StartLimit* options were moved from &quot;Service&quot; to &quot;Unit&quot; in systemd 229.</span><br><span class="line"># Both the old, and new location are accepted by systemd 229 and up, so using the old location</span><br><span class="line"># to make them work for either version of systemd.</span><br><span class="line">StartLimitBurst=3</span><br><span class="line"></span><br><span class="line"># Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.</span><br><span class="line"># Both the old, and new name are accepted by systemd 230 and up, so using the old name to make</span><br><span class="line"># this option work for either version of systemd.</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line"># Comment TasksMax if your systemd version does not support it.</span><br><span class="line"># Only systemd 226 and above support this option.</span><br><span class="line">TasksMax=infinity</span><br><span class="line"></span><br><span class="line"># set delegate yes so that systemd does not reset the cgroups of docker containers</span><br><span class="line">Delegate=yes</span><br><span class="line"></span><br><span class="line"># kill only the docker process, not all processes in the cgroup</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li>设置开机自启和启动 docker <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure></li><li>卸载，直接删除 docker.service 文件和复制到 &#x2F;usr&#x2F;bin 中的 docker 目录即可</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用-YUM-命令安装&quot;&gt;&lt;a href=&quot;#使用-YUM-命令安装&quot; class=&quot;headerlink&quot; title=&quot;使用 YUM 命令安装&quot;&gt;&lt;/a&gt;使用 YUM 命令安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装 docker 依赖软件&lt;figure class=</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker-compose 学习记录</title>
    <link href="http://example.com/wiki/Docker/docker-compose%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/wiki/Docker/docker-compose%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-31T13:39:26.110Z</published>
    <updated>2023-05-31T13:39:26.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-compose-介绍"><a href="#docker-compose-介绍" class="headerlink" title="docker-compose 介绍"></a>docker-compose 介绍</h2><p>docker-compose 是用来定义和管理多容器运行的 docker 应用程序，通过 YAML 配置文件和简单的 Docker-Compose 命令就可以管理和控制 docker 容器的生命周期和日志，其可以看作是 docker 容器自动化管理工具。</p><p>docker-compose 是以 project 和 service 的概念去管理 docker 容器的，每一个容器是一个 service，每一个或者多个 docker-compose 配置文件所在的目录是一个 project, project 的名称默认是配置文件的上层目录名。</p><p>注意 docker-compose 管理的是 service, 所以 dokcer-compose 命令是以 service 维度去操作管理 docker 容器的。</p><h2 id="docker-compose-常用命令的简单介绍"><a href="#docker-compose-常用命令的简单介绍" class="headerlink" title="docker-compose 常用命令的简单介绍"></a>docker-compose 常用命令的简单介绍</h2><p>docker-compose 命令运行时，会默认读取当前目录的 docker-compose 配置文件，如果 docker-compose 命令运行所在目录不存在 docker-compose 文件，则需要要使用 -f 指定 docker-compose 配置文件或者指定使用 -p 指定 project 的名称。</p><p>docker-compse 命令详细用法使用 <code>--help</code> 方式查看，如果查看 docker-compose ps 的详细用法，运行 <code>docker-compose ps --help</code> 命令即可。以下是 docker-compose 部分命令解释说明。</p><h4 id="docker-compose-pull"><a href="#docker-compose-pull" class="headerlink" title="docker-compose pull"></a>docker-compose pull</h4><p>根据 docker-compose 配置文件拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认拉取 docker-compose 配置文件所有 service 的镜像</span></span><br><span class="line">docker-compose pull </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据服务名称拉取单个或者多个服务的镜像</span></span><br><span class="line">docker-compose pull [service-name]</span><br><span class="line"></span><br><span class="line">docker-compose pull [service-name1] [serivce-name2]</span><br></pre></td></tr></table></figure><h4 id="docker-compose-create"><a href="#docker-compose-create" class="headerlink" title="docker-compose create"></a>docker-compose create</h4><p>创建或者重建运行中容器，命令执行成功后，容器的状态都是 Created 状态，表示只是创建了容器，并未运行容器，所以要注意重建运行中的容器后，容器的状态将由 Running 状态变成 Created 服务无法在使用，必须要 <code>docker-compose start </code> 启动容器后才可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据 docker-compose 配置文件中的镜像创建容器或者重建运行中的容器，容器的状态会变成 Created 状态</span></span><br><span class="line">docker-compose create </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据一个或者多个服务名称创建或者重建运行中的容器</span></span><br><span class="line">docker-compose create [service-name]</span><br><span class="line"></span><br><span class="line">docker-compose create [service-name1] [service-name2]</span><br></pre></td></tr></table></figure><h4 id="docker-compose-start"><a href="#docker-compose-start" class="headerlink" title="docker-compose start"></a>docker-compose start</h4><p>启动 Created 状态的容器，命令执行成功后，容器状态变成 Running 状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据 docker-compose 配置文件启动所有 Created 状态的容器</span></span><br><span class="line">docker-compose start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据一个或者多个服务名启动 Created 状态的容器</span></span><br><span class="line">docker-compose start [service-name1] </span><br><span class="line"></span><br><span class="line">docker-compose start [service-name1] [service-name2]</span><br></pre></td></tr></table></figure><h4 id="docker-compose-run"><a href="#docker-compose-run" class="headerlink" title="docker-compose run"></a>docker-compose run</h4><p>创建容器并启动容器，等价于运行 <code>docker-compose create</code> 和 <code>docker-compose start</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后台守护进程的方式创建和运行 docker-compose 配置文件中的镜像容器</span></span><br><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure><h4 id="dockerc-compose-down"><a href="#dockerc-compose-down" class="headerlink" title="dockerc-compose down"></a>dockerc-compose down</h4><p>停止和删除 docker-compose 配置文件中的所有容器和网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down </span><br></pre></td></tr></table></figure><h4 id="docker-compose-logs"><a href="#docker-compose-logs" class="headerlink" title="docker-compose logs"></a>docker-compose logs</h4><p>查看容器日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据服务名查看容器的日志</span></span><br><span class="line">docker-compose logs &lt;service-name&gt; -f --<span class="built_in">tail</span>=200</span><br></pre></td></tr></table></figure><h4 id="docker-compose-exec"><a href="#docker-compose-exec" class="headerlink" title="docker-compose exec"></a>docker-compose exec</h4><p>运行容器中的命令或者进入容器内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据服务名进入容器内部</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> -it &lt;service-name&gt; &lt;/bin/sh | /bash&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据服务名运行容器中的命令</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> -it &lt;service-name&gt; <span class="built_in">ls</span> -il</span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">exec</span> -it &lt;service-name&gt; <span class="built_in">env</span> <span class="comment"># 查看环境变量</span></span><br><span class="line"></span><br><span class="line">docker-compose <span class="built_in">exec</span> -it &lt;service-name&gt; nginx -t <span class="comment"># 运行 nginx 配置文件验证命令</span></span><br></pre></td></tr></table></figure><h4 id="docker-compose-cp"><a href="#docker-compose-cp" class="headerlink" title="docker-compose cp"></a>docker-compose cp</h4><p>将容器的文件或者文件夹复制到宿主机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  将宿主机中的 /home/sysadmin/data/hello.txt 文件复制到容器的 /data 目录下</span></span><br><span class="line">docker-compose <span class="built_in">cp</span> /home/sysadmin/data/hello.txt &lt;serivce-name&gt;:/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器中的 /data/hello.txt 文件复制到宿主机的 /home/sysadmin/data 目录下</span></span><br><span class="line">docker-compose <span class="built_in">cp</span> &lt;serivce-name&gt;:/data/hello.txt /home/sysadmin/data </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-compose-介绍&quot;&gt;&lt;a href=&quot;#docker-compose-介绍&quot; class=&quot;headerlink&quot; title=&quot;docker-compose 介绍&quot;&gt;&lt;/a&gt;docker-compose 介绍&lt;/h2&gt;&lt;p&gt;docker-com</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
  </entry>
  
</feed>
